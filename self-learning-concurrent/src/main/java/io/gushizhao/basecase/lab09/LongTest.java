package io.gushizhao.basecase.lab09;

/**
 * @Author huzhichao
 * @Description TODO
 * @Date 2023/3/24 15:10
 *
 * 我们在32位多核CPU的计算机上以多线程的方式读写long类型的共享变量时，线程已经将变量成功写入了内存，但是重新读取出
 * 来的数据和之前写入的数据不一致，这到底是为什么呢？
 *
 * 其实，造成这个问题的根本原因就是线程的原子性问题，而线程的原子性问题最终的“幕后黑手”是线程切换，如果能够禁用线程
 * 切换就能够解决这个问题了！在操作系统层面来看，操作系统做线程切换需要依赖CPU的中断机制，所以说，禁止CPU发生中断
 * 就能够禁止线程切换。
 *
 * 这种方案在单核CPU上是可行的，但是并不适合多核CPU。
 *
 * long型变量是64位的，在32位CPU上执行写操作，会被拆分成写高32位和写低32位两部分，如果此时有多个线程同时写long型
 * 变量的高32位的话，就有可能出现诡异的Bug问题。
 * 注意：不只是long型变量，在32位多核CPU上并发写64位数据类型的数据，都会出现类似的诡异问题！！！
 */
public class LongTest {
}
