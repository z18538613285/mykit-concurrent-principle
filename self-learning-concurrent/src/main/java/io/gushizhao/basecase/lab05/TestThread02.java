package io.gushizhao.basecase.lab05;

/**
 * @Author huzhichao
 * @Description TODO
 * @Date 2023/3/24 9:21
 *
 * 并发问题的“幕后黑手”
 * 源头二，线程切换带来的原子性问题
 *
 * 原子性是指一个或者多个操作在CPU中执行的过程不被中断的特性
 *
 * 在现代操作系统中，一般都提供了多进程和多线程的功能。操作系统允许进程执行一小段时间，过了这段时间，操作系统就会重
 * 新选择一个进程来执行。我们称这种情况叫做任务切换，这一小段时间被称为时间片。
 * 在如今的操作系统中，大部分的任务切换都是基于线程来执行的，我们也可以将任务切换叫作线程切换。
 *
 * Java并发程序是基于多线程来编写的，这也会涉及到CPU对任务的切换。正是CPU中对任务的切换机制，造成了并发编程中的第
 * 二个诡异的问题。
 *
 * count ++；
 * 看似简单的一条count自增的代码，实际上对应着CPU中的多条指令。我们将CPU的指令简化成如下三步操作。
 * 指令1：把变量count从内存加载的CPU寄存器。
 * 指令2：在寄存器中执行count++操作。
 * 指令3：将结果写入缓存（可能是CPU缓存，也可能是内存）。
 *
 * CPU能够保证的原子性是CPU指令级别的，而不是编程语言级别的。我们在编写高并发程序时，需要在编程语言级别保证
 * 程序的原子性。
 */
public class TestThread02 {


}
