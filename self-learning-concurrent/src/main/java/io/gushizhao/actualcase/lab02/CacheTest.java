package io.gushizhao.actualcase.lab02;

/**
 * @Author huzhichao
 * @Description TODO
 * @Date 2023/3/28 9:35
 *
 * 缓存穿透
 * 首先，我们来说说缓存穿透。什么是缓存穿透呢？缓存穿透问题在一定程度上与缓存命中率有关。如果我们的缓存设计的不合
 * 理，缓存的命中率非常低，那么，数据访问的绝大部分压力都会集中在后端数据库层面。
 * 什么是缓存穿透？
 * 如果在请求数据时，在缓存层和数据库层都没有找到符合条件的数据，也就是说，在缓存层和数据库层都没有命中数据，那么，
 * 这种情况就叫作缓存穿透。
 *
 *缓存击穿
 * 如果我们为缓存中的大部分数据设置了相同的过期时间，则到了某一时刻，缓存中的数据就会批量过期。
 * 什么是缓存击穿？
 * 如果缓存中的数据在某个时刻批量过期，导致大部分用户的请求都会直接落在数据库上，这种现象就叫作缓存击穿。
 *
 * 缓存雪崩
 * 如果缓存系统出现故障，所有的并发流量就会直接到达数据库。
 * 什么是缓存雪崩？
 * 如果在某一时刻缓存集中失效，或者缓存系统出现故障，所有的并发流量就会直接到达数据库。数据存储层的调用量就会暴增，
 * 用不了多长时间，数据库就会被大流量压垮，这种级联式的服务故障，就叫作缓存雪崩。
 *
 *
 * 缓存命中率
 * 缓存命中率是从缓存中读取数据的次数与总读取次数的比率，命中率越高越好。缓存命中率=从缓存中读取次数 / (总读取次数 (从
 * 缓存中读取次数 + 从慢速设备上读取次数))。这是一个非常重要的监控指标，如果做缓存，则应通过监控这个指标来看缓存是否
 * 工作良好。
 * 缓存类型
 * 缓存类型总体上来看，可以分为：堆缓存、堆外缓存、磁盘缓存和分布式缓存。
 *
 *堆内存
 * 使用Java堆内存来存储对象。使用堆缓存的好处是没有序列化/反序列化，是最快的缓存。缺点也很明显，当缓存的数据量很大
 * 时，GC（垃圾回收）暂停时间会变长，存储容量受限于堆空间大小。一般通过软引用/弱引用来存储缓存对象。即当堆内存不足
 * 时，可以强制回收这部分内存释放堆内存空间。一般使用堆缓存存储较热的数据。可以使用Guava Cache、Ehcache 3.x、
 * MapDB实现。
 *
 * 堆外内存
 * 即缓存数据存储在堆外内存，可以减少GC暂停时间（堆对象转移到堆外，GC扫描和移动的对象变少了），可以支持更多的缓存
 * 空间（只受机器内存大小限制，不受堆空间的影响）。但是，读取数据时需要序列化/反序列化。因此，会比堆缓存慢很多。可以
 * 使用Ehcache 3.x、 MapDB实现。
 *
 * 磁盘缓存
 * 即缓存数据存储在磁盘上，在JVM重启时数据还存在，而堆/堆外缓存数据会丢失，需要重新加载。可以使用Ehcache 3.x、
 * MapDB实现。
 *
 * 分布式缓存
 * 分布式缓存可以使用ehcache-clustered(配合Terracotta server)实现Java进程间分布式缓存。也可以使用Memcached、Redis实
 * 现。
 * 使用分布式缓存时，有两种模式如下：
 * 单机模式：存储最热的数据到堆缓存，相对热的数据到堆外缓存，不热的数据到磁盘缓存。
 * 集群模式：存储最热的数据到堆缓存，相对热的数据到对外缓存，全量数据到分布式缓存。
 *
 * 缓存回收策略
 * 缓存的回收策略总体上来说包含：基于空间的回收策略、基于容量（空间）的回收策略、基于时间的回收策略和基于对象引用的
 * 回收策略。
 *
 *基于空间
 * 基于空间指缓存设置了存储空间，如设置为10MB，当达到存储空间上限时，按照一定的策略移除数据。
 * 基于容量
 * 基于容量指缓存设置了最大大小，当缓存的条目超过最大大小时，按照一定的策略移除旧数据。
 * 基于时间
 *  TTL(Time To Live):存活期，即缓存数据从创建开始直到到期的一个时间段（不管在这个时间段内有没有被访问，缓存数据都将
 * 过期）。
 *  TTI(Time To Idle)：空闲期，即缓存数据多久没被访问后移除缓存的时间。
 *
 *基于对象引用
 * 软引用：如果一个对象是软引用，则当JVM堆内存不足时，垃圾回收器可以回收这些对象。软引用适合用来做缓存，从而当JVM
 * 堆内存不足时，可以回收这些对象腾出一些空间供强引用对象使用，从而避免OOM。
 * 弱引用：当垃圾回收器回收内存时，如果发现弱引用，则将它立即回收。相对于软引用，弱引用有更短的生命周期。
 * 注意：只有在没有其他强引用对象引用弱引用/软引用对象时，垃圾回收时才回收该引用。即如果有一个对象（不是弱引用/软引
 * 用对象）引用了弱引用/软引用对象，那么垃圾回收时不会回收该弱引用/软引用对象。
 *
 *回收算法
 * 使用基于空间和基于容量的缓存会使用一定的策略移除旧数据，通常包含：FIFO算法、LRU算法和LFU算法。
 *
 * FIFO(First In First Out)：先进先出算法，即先放入缓存的先被移除。
 * LRU(Least Recently Used)：最近最少使用算法，时间时间距离现在最久的那个被移除。
 * LFU(Least Frequently Used)：最不常用算法，一定时间段内使用次数（频率）最少的那个被移除。
 * 实际应用中基于LRU的缓存居多
 *
 */
public class CacheTest {
}
